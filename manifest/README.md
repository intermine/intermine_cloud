## TODO

- Expose Argo web server in *base/argo.yaml* so you don't have to use Argo CLI for dashboard.
  - for overlays/dev only?
- Handle keys and passwords using `secretGenerator` (ideally they should be autogenerated on deploy-time) and https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/
- Use `vars`

## Requirements

### If using `k3s` overlay

These resources include [Longhorn](https://longhorn.io/) for storage. This requires some extra work on your hosts. You will need to install the `open-iscsi` package and [change the default storage class](https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/) to `longhorn`.

## Usage

Deploy/update all resources for a dev environment.

```
kubectl apply -k overlays/dev
```

There are also `kind` and `k3s` overlays.

This will not remove previously created resources that have been deleted here, unless you add: `--prune -l app.kubernetes.io/part-of=intermine_cloud`

To uninstall all the resources, use the `apply` invocation with `delete` instead:

```
kubectl delete -k overlays/dev
```

If there have been made changes to the manifests since you deployed it, this might not delete all the resources. To achieve this, you can use:

```
kubectl delete all -l app.kubernetes.io/part-of=intermine_cloud --all-namespaces
```

**Argo UI**: `kubectl -n argo port-forward service/argo-server 2746:2746` then open https://localhost:2746 and accept the SSL certificate. Use `echo Bearer $(kubectl -n argo get secret $(kubectl -n argo get sa argo -o=jsonpath='{.secrets[0].name}') -o=jsonpath='{.data.token}' | base64 --decode)` to get the token for client authentication. Mine workflows are created in the `workflow` namespace -- remember to input this to the *Namespace* filter and hit *Enter*.

**MinIO console**: `kubectl -n compose port-forward service/compose-minio-console 9001:9001` then open http://localhost:9001 and use `kubectl -n compose get secret/compose-minio -o jsonpath='{.data.rootUser}' | base64 --decode` and `kubectl -n compose get secret/compose-minio -o jsonpath='{.data.rootPassword}' | base64 --decode` to get the access and secret keys.

## Development

### Stubbing compose

When developing the workflow (demon/src/demon/templates/minebuilder.yaml.template) or Kustomize manifests, you might want to stub the SaaS backend. You can do this by accessing the MinIO console (instructions above) and creating a bucket with the name `my-bucket` and the following custom access policy.

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": [
                    "*"
                ]
            },
            "Action": [
                "s3:GetObject",
                "s3:PutObject"
            ],
            "Resource": [
                "arn:aws:s3:::my-bucket/*"
            ]
        },
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": [
                    "*"
                ]
            },
            "Action": [
                "s3:GetBucketLocation"
            ],
            "Resource": [
                "arn:aws:s3:::*"
            ]
        }
    ]
}
```

You will need to manually upload `source.tgz` and `mine.tgz` archives to the bucket, containing sources and a mine directory to be built.

Use the following commands to publish a mine workflow to *NATS*. This example uses Biotestmine, but you can modify it for other mines as well. Make sure to fill in `STUB_access_key` and `STUB_secret_key` using `rootUser` and `rootPassword` from the MinIO secret (see instructions for **MinIO console** above).

```
kubectl -n compose exec deploy/compose -it  -- /bin/sh
blackcap pub custom --data '{
  "job": {
    "name": "minex-build",
      "job_type": "build",
      "specification": {
        "mine_name": "biotestmine",
        "pretty_mine_name": "Biotestmine",
        "source_name": "malaria",
        "sources": [
          "uniprot-malaria",
          "malaria-gff",
          "malaria-chromosome-fasta",
          "entrez-organism"
        ],
        "post_processing": [
          "create-references",
          "do-sources",
          "summarise-objectstore",
          "create-autocomplete-index",
          "create-search-index"
        ],
        "get_sources": "http://compose-minio.compose.svc.cluster.local:9000/my-bucket/source.tgz",
        "get_minedir": "http://compose-minio.compose.svc.cluster.local:9000/my-bucket/mine.tgz",
        "post_postgres": "STUBBED",
        "post_solr": "STUBBED",
        "STUB_endpoint": "http://compose-minio.compose.svc.cluster.local:9000/",
        "STUB_access_key": "<FILL>",
        "STUB_secret_key": "<FILL>"
      }
  }
}'
```

*Demon* should pick this up and create the *Argo* workflow. Access the Argo UI (instructions above) to see the progress of this. Once it's completed, an *intermineinstance* CRD will be created in the `mine` namespace, which the *intermine operator* will use to create all the resources, in the same `mine` namespace.

### Generating base manifests

The first time you'll need to add the Helm repositories containing the charts.

```
helm repo add minio https://charts.min.io/
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo add nats https://nats-io.github.io/k8s/helm/charts/
helm repo update
```

Then you can generate the manifests.

```
# Argo defaults to latest tags -- you should manually replace this with a versioned tag in the interest of avoiding breakage.
curl https://raw.githubusercontent.com/argoproj/argo-workflows/master/manifests/install.yaml > base/argo/argo.yaml
curl https://raw.githubusercontent.com/longhorn/longhorn/master/deploy/longhorn.yaml > overlays/k3s/longhorn-system/longhorn.yaml
helm template compose bitnami/postgresql > base/compose/postgresql.yaml
helm template --set replicas=4 compose minio/minio > base/compose/minio.yaml
helm template nats nats/nats > base/nats/nats.yaml
pushd ../helm-operator ; kustomize build config/default > ../manifest/base/intermine-operator-system/intermine_operator.yaml ; popd
```

Make sure to review the diffs, as sometimes manual changes have to be made to the source manifests.
